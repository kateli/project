#`http`的缓存机制和原理

##### 1.3.1 `http`报文
`http` 报文就是浏览器和服务器间通信时发送及响应的数据块。

浏览器向服务器请求数据，发送请求（`request`）报文；服务器向浏览器返回数据，返回响应（`response`）报文。

报文信息主要分为两部分：

1.包含属性的首部（`header`）---------- 附加信息（`cookie`，缓存信息等）与缓存相关的规则信息，均包含在header中。

2.包含数据的主体部分（`body`）---------- http请求真正想要传输的部分。

##### 1.3.2 缓存规则解析
为方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息。

在客户端第一次请求数据时，此时缓存数据库中并没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。

![avatar](../images/http01.png)

`http`缓存有多种规则，根据是否需要重新向服务器端发起请求来分类，将其分为两大类（强制缓存，对比缓存），在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则，有个简单的了解。

已存在缓存数据时，仅基于强制缓存，请求数据的流程如下
![avatar](../images/http02.png)

已存在缓存数据时，仅基于对比缓存，请求数据的流程如下
![avatar](../images/http03.png)

我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存，不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，则直接使用缓存，不在执行对比缓存规则。

##### 1.3.3  强制缓存
从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据。那么浏览器是如何判断缓存数据是否失效的呢?

我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应`header`中。

对于强制缓存来说，响应`header`中会有两个字段来标明失效规则（`Expires/Cache-Control`）。强制缓存生效时，网络请求的情况：
![avatar](../images/http04.png)

###### 1.3.3.1  `Expires`
`Expires`的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务器的到期时间，直接使用缓存数据。不过`Expires`是`http1.0`的东西，它的作用基本忽略。

另个一个问题是，到期时间是由服务端生成的，但是客户端时间可能和服务端时间有误差，这就会导致缓存命中的误差。所以`http1.1`的版本，使用`Cache-Control`替代。

###### 1.3.3.2  `Cache-Control`
`Cache-Control` 是最重要的规则。常见的取值有`private`,`public`,`no-cache`,`max-age`,`no-store`，默认为`private`。
* `private`：客户端可以缓存
* `public`：客户端和代理服务器都可以缓存
* `max-age=xxx`：缓存的内容将在xxx秒后失效
* `no-cache`：需要使用对比缓存来验证数据缓存
* `no-store`：所有内容都不会缓存，强制缓存，对比缓存，都不会触发（对于前端开发来说，缓存越多越好，所以基本上和它说拜拜了）
例如：
![avatar](../images/http05.png)
图中`Cache-control`仅指定了`max-age`，所以默认为`private`，缓存时间为31536000秒（365天），在365天内再次请求这条数据，都会直接使用缓存。

##### 1.3.4  对比缓存
对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。

浏览器第一次请求服务器时，服务器会将缓存标识和数据，一起返回给客户端，客户端将两者备份至缓存数据库中。再次请求的时候，客户端将备份的缓存标识，发送给服务器端，服务器端根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

第一次访问：
![avatar](../images/http06.png)

再次访问：
![avatar](../images/http07.png)

通过两图的对比可以发现，对比缓存生效时，状态码是304，而且报文大小和请求时间大大减小。因为服务端进行标识比较后，服务端只返回header部分，通过状态码通知客户端使用缓存，不需要再将报文主体部分返回给客户端。

##### 1.3.5  缓存标识
分为两种：`Last-Modified / If-Modified-Since`  和   `Etag / If-None-Match`

###### 1.3.5.1  `Last-Modified / If-Modified-Since`
`Last-Modified`：
服务器在响应请求时，告诉浏览器资源的最后修改时间。
![avatar](../images/http08.png)

`If-Modified-Since`：
再次请求服务器时，服务器通过请求头部的`If-Modified-Since`字段与被请求的资源的最后修改时间进行对比。

若资源的最后修改时间大于`If-Modified-Since`，说明资源又被修改过，则响应整片资源内容，返回状态码200。

若资源的最后修改时间，小于`If-Modified-Since`，说明资源没有被修改过，则响应状态码304，告知客户端，从缓存中读取。

![avatar](../images/http09.png)

###### 1.3.5.2  `Etag  /  If-None-Match`（优先级高于`Last-Modified`  /  `If-Modified-Since`）
`Etag`:

服务器端响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器端决定）。
![avatar](../images/http10.png)

`If-None-Match`:

再次请求服务器端的时候，服务器端发现头部有`If-None-Match`字段，则与上次的Etag字段进行对比。
如果不同，则说明资源被改动过，则响应整片资源内容，返回状态码200。
如果相同，则说明资源没有被修改过，返回状态码304，告知客户端，从缓存中取。
![avatar](../images/http11.png)

##### 1.3.6  总结
对于强制缓存，服务器端会返回浏览器端一个过期时间，在这个时间内，下次请求的时候，直接取缓存，不在这个时间内，则采用对比缓存策略。
对于比较缓存，将缓存信息中的 `Etag`和`Last-Modified`发送给服务器端，服务器进行校验，返回304，则客户端直接使用缓存。

浏览器第一次请求

![avatar](../images/http12.png)

浏览器再次请求

![avatar](../images/http13.png)